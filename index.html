<!DOCTYPE html>
<html>
<head>
  <title>Building Your Own Federated Search</title>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <style type="text/css">
    @import url(http://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
    @import url(http://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
    @import url(http://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

    body { 
      font-family: 'Droid Serif';
    }
    h1, h2, h3 {
      font-family: 'Yanone Kaffeesatz';
      font-weight: normal;
    }
    img { width: 100%; }
    .remark-slide-content {
      color: white;
      background-color: black;
    }
    a {
      color: white;
    }
    .remark-code, .remark-inline-code { 
      font-family: 'Ubuntu Mono';
      text-align: left;
    }
  </style>

  <base target="_blank" />
</head>
<body>
  <textarea id="source">

layout: true
class: center, middle

---

# Building Your Own Federated Search 

https://trott.github.io/building-your-own-federated-search

???

Let's talk about building your own federated search.

---

# What

???

Before we build it, I guess we ought to know what it is.

---

<img alt="" src="img/ghostbusted.svg" width="600" height="600">

???

For starters, it's not metasearch, which I guess means I better take ten seconds to distinguish between federated search and metasearch.

---

# Metasearch: one index, multiple resources

???

Metasearch operates on a one consolidated index harvested from multiple sources; Summon and similar products are metasearch tools.

---

# Federated search: one index per resource

???

Federated search is more like running the same search on ten different search engines all at once and getting ten different result sets.

---

# There are pros&hellip;

???

Reasons you might want to do this instead of metasearch include&hellip;

---

# $

???

&hellip;higher cost for implementing metasearch&hellip;

---

# Extensibility 

???

&hellip;and flexibility to include pretty much anything you can search rather than only things for which you have access to complete metadata.

---

# There are cons&hellip;

???

There are disadvantages to be aware of.

---

# Multiple result sets

???

Getting ten different result sets can be overwhelming compared to a single, sorted result set.

---

# But really, why?

???

Let's say you have dozens of online resources and each of these online resources has its own search tool.

---

# Here are the 387 URLs to try&hellip;

???

But users shouldn't be asked to search in dozens of different interfaces to find what they're looking for.

---

# Have we mentioned $?

???

You're cash-constrained&hellip;

---

# I am a special snowflake.

???

&hellip;or you have a specialized collection set that needs searching that is not handled adequately by existing discovery products&hellip;

---

# Hi, I'm Cyndi Lauper, and I create amazing user experiences.

???

&hellip;or just want to have some fun creating something.

---

# Let's federate some search already!

???

So your focus is on federated search because it's frankly simpler and cheaper than metasearch.

---

# 3 Is A Magic Number

Yes it is. It's a magic number.

<small>Somewhere in the ancient mystic trinity, you get 3. That's a magic number.

<small>The past and the present and the future&hellip;

<small>&hellip;faith and hope and charity&hellip;

<small>&hellip;the heart and the brain and the body&hellip;

<small>&hellip;give you 3.

<small>That's a magic number.</small></small></small></small></small></small>

???

There are (at least) three ways to pull data out of other resources in real time, and here they are in descending order of desirability.

---

# #1 

## Cool, they have an API for that!

<span class="blink">This almost never happens.</span>

???

Number 1: The content provider might publish an API, which is somethingf that almost never happens. 

---

# Faux APIs will break your heart.

???

Often what you and I consider an API is not what the content providers consider an API. 

---

# You keep using that word. 

I do not think it means what you think it means.

???

If you give me a script tag that injects a widget into my page, and then you call it an API, that is not an API.

--- 

# #2

## Screen-scrape the #*%!Â out of it.

This is by far the most common scenario.

???

Then there's straightforward grab-the-HTML and scrape the information out of it.

---

# <span style="color: red">WARNING</span>

???

As we all know, this brittle because the HTML can change and break your scraper. 

---

# <span style="color: green">UPSIDES</span>

???

But it has two big upsides.

---

# Better than the alternative&hellip;

&hellip;which is nothing.

???

Number 1: It usually works well enough.

---

# You can actually do it.

???

And number 2: It is usually easy and fast to implement.

--- 

# Web New-dot-Oh

It's full of JavaScript frameworks.

???

Lastly, there's what you have to do when confronted with a site powered by front-end technologies where none of the content shows up unless you execute a bunch of JavaScript.

---

# Headless browsers to the rescue

???

For this, make friends with headless browsers like PhantomJS to scrape these sites.

---

# <span style="color: yellow">CAUTION</span>

???

This should be your last resort, not your first choice. 

---

# Fast!

But not that fast.

???

Headless browsers are fast compared to Safari and Internet Explorer, but they're slow compared to curl or API calls.

---

# I have no opinion&hellip;

&hellip;except when I do.

???

I like to think I'm technology-agnostic and it's probably fine if you've concluded the way to do this is to code up a bunch of enterprise Java, compile it to a WAR file, and deploy that to your Tomcat server.

---

# JavaScript FTW

???

But it's impossible to deny that **&quot;JavaScript has a more robust and widely-understood set of conventions and tools for processing blobs of HTML than any other programming language.&quot;**

---

# JS &amp; HTML

BFF

???

It has built-in DOM-handling, a million battle-tested libraries with simple and powerful jQuery-like selectors, and its sole reason for existing is the web and HTML.

---

# Node.js FTW

???

So we decided that it probably made sense to build our federated search server using Node.js.

---

# Browserify FTW

???

Or maybe even take it a step further and just put all the federated search code entirely in the browser with no intermediary server whatsoever.

---

# Amalgamatic

## https://github.com/ucsf-ckm/amalgamatic

???

First, we wrote a pluggable, extensible federated search tool called Amalgamatic.

---

### `npm install --save amalgamatic`

???

You install it with `npm`. 

---

### `npm install --save amalgamatic-pubmed`

???

By itself, it doesn't do much, so you need to install plugins too, which we'll get to in a minute.

---

````javascript
// Load Amalgamatic
var amalgamatic = require('amalgamatic');

// Load some plugins to search PubMed and SFX.
var pubmed = require('amalgamatic-pubmed');
var sfx = require('amalgamatic-sfx');

// Add the plugins to Amalgamatic.
amalgamatic.add('sfx', sfx);
amalgamatic.add('pubmed', pubmed);

var callback = function (err, results) {
  if (err) {
    console.dir(err);
  } else {
    results.forEach( function (result) {
      console.log('\nCollection name: ' + result.name);
      console.dir(result.data);
    });
  }
};

// Do a search!
amalgamatic.search({searchTerm: 'medicine'}, callback);
````

???

Here's a sample minimal server, if you care.

---

# Amalgamatic plugins

#### https://www.npmjs.org/browse/keyword/amalgamatic-plugin

???

Now about those plugins.

We wrote the ones that we needed to search the resources we were interested in.

In the course of writing these plugins, we used all three of the techniques described earlier:

API, scraping HTML, and using a headless browser to get JavaScript-generated content.

All the plugins are published via npm and tagged `amalgamatic-plugin` so you can find them at the URL or using `npm search`.

---

# API server

## Node.js, Express

### https://github.com/Trott/apis.ucsf.edu

???

Third, we used Amalgamatic to expose federated search on our Node.JS-powered API server.

---

# Federated search prototype

## http://search.library.ucsf.edu/

???

Fourth, we set up a prototype search interface to use that API.

Obligatory HTML5 API shoutout to EventSource! 

If you don't know it, look it up, it rules. 

It's one of the unsung majesticly awesome APIs, powerful and simple, and it doesn't get the attention it deserves.

---

# Browserified Demo

### http://trott.github.io/demo-amalgamatic-browserify/

???

Lastly, because we could, we used Browserify to create a demo showing how to use Amalgamatic so that all the retrieval and processing happens in the browser</a>&mdash;no need for an intermediary API or search server! 

A small caveat on the Browserify-ed version: One thing the browser couldn't do was launch the headless browser for scraping sites that depend on JavaScript execution to display results. 

So maybe there's another reason to keep that as a last resort technique only.

---

class: middle

````javascript
var amalgamatic = require('amalgamatic');

var sfx = require('amalgamatic-sfx');
sfx.setOptions({
    url: 'http://cors-anywhere.herokuapp.com/ucelinks.cdlib.org:8888/sfx_ucsf/az'
});

amalgamatic.add('sfx', sfx);

var drupal6 = require('amalgamatic-drupal6');
drupal6.setOptions({
    url: 'http://cors-anywhere.herokuapp.com/www.library.ucsf.edu/search/node'
});
amalgamatic.add('drupal6', drupal6);

&hellip;
````

???

Here's the start of the JavaScript code that our Browserify demo app uses.

Here you can see our cheat.

Instead of using the source we want to scrape directly, we're running it through a free CORS proxy.

There's a few free CORS proxies out there, and I chose CORS Anywhere for my demo.

You don't need this for APIs that send CORS headers.

But for other APIs, and for screen scraping, you'll need some CORS headers added.

---

class: middle

````javascript
var options = {
  searchTerm: searchTerm, // We snarfed this from the form earlier
  
  pluginCallback: function (err, result) {
    var elem = document.getElementById(result.name);
    if (err) {
      elem.textContent = err.message;
    } else {
      if (result.data.length) {
        // Code that inserts results into the DOM
      } else {
        elem.innerHTML = 'No results. :-(';
      }
    }
  }

};

amalgamatic.search(options);
````
???

And here's the code that does the search.

You'll notice here that we're not using a callback in the search call at the bottom.

Instead, there's a plugin callback specified in the options object. 

The plugin callback is called for each plugin when it returns its results.

The global callback, in contrast, runs when all the results return.

Using the plugin callback allows us to show results as they arrive rather than making the user wait for the slowest plugin to return before showing anything.
---

class: middle

`# browserify -o bundle.js main.js`

???

Next, we take that JavaScript, which is in `main.js`, and we bundle it up with Browserify into `bundle.js`.

---

class: middle

````html
<script src="bundle.js"></script>
````

???

Finally, we include the bundle in our HTML file.

---

<img src="img/calendar.png" alt="">

???

Now, I've been using amalgamatic for search, but I want to encourage people to think creatively about this.

It can really be used to scrape anything.

So you can basically take something that doesn't have an API, and create your own API.

Like...maybe...this thing.

The much-maligned HTML5DevConf online schedule.

I don't begrudge the conference about this. 

This is a super-affordable conference powered by volunteers and a shoestring budget.

Yesterday, I thought, "If all the people complaining about the schedule would channel that effort towards fixing it, we'd be all set."

---

### https://github.com/ucsf-ckm/amalgamatic-h5dcsched

???

So I wrote an Amalgamatic plugin for the HTML5DevConf calendar.

And gave it a horrible name.

But the code is straightforward HTML scraping.

---

### https://github.com/Trott/devconf-calendar

???

Then I wrote a quick browserified page to use the plugin to dump JSON calendar data onto a page.

---

### http://trott.github.io/devconf-calendar

???

And we can see it here, and hope it works, WiFi-willing.

---

# Step 3: Profit!

<img src="img/twitter.png" alt="" />

???

Then I tweeted about it and waited for someone to use the data to make a killer calendar interface.

It didn't happen.

To be fair, I tweeted about it just before midnight yesterday, so not a lot of time and diminishing benefits for someone to do the work. 

But you know, maybe next year I'll think of doing this a day ahead of the conference rather than halfway into it.

---

# Thanks!!

## https://trott.github.io/curing-cancer-with-html5

Rich Trott  
@trott  
UC San Francisco  

  </textarea>
  <script src="js/remark.min.js">
  </script>
  <script type="text/javascript">
  var slideshow = remark.create();
  </script>
  <script>
  var blinks = document.querySelectorAll('.blink');
  blinks.forEach(function (blink) {
    setInterval(function() { blink.style.visibility = blink.style.visibility ? '' : 'hidden';}, 750);
  });
  </script>
</body>
</html>